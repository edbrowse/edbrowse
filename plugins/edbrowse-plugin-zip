#!/bin/bash

if [ $# != 1 ] ; then
echo "usage edbrowse-plugin-zip zipfile[path]"
exit 1;
fi

# This script assumes all ascii characters, and nice characters too,
# not < ; " \ etc.
# this is not ideal.
# the next two functions move us toward a better solution.

# We're going to generate <a> tags in html, with links that look like urls.
# the url holds the zip file and the path inside.
# If there are any odd characters in these paths, like < > or nonascii,
# and if we don't percent encode them here, edbrowse is going to do it for us.
# We have no choice.
# perl is the easiest way to encode and decode.

function uriEscape {
echo "$1" | perl -e 'use URI::Escape; my $s = <>; chomp $s; print uri_escape $s;'
}

function uriUnescape {
echo "$1" | perl -e 'use URI::Escape; my $s = <>; chomp $s; print uri_unescape $s;'
}

#  gather the zip file and path
zf="$1"
path=""
if [[ "$zf" =~ @:@ ]] ; then
# zip file is before @:@, path is after
path=${zf/*@:@/}
zf=${zf/@:@*/}
# protocol is either zipx or zipxd
#  check here for file extract
if [[ "$zf" =~ zipx: ]] ; then
zf=${zf/zipx:??/}
unzip -p "$zf" "$path"
exit 0
fi
zf=${zf/zipxd:??/}
fi

# we're generating html, whence we can make links that edbrowse understands
echo "<body>Zip Archive"
if [ -z "$path" ] ; then
#  this is the root directory
unzip -t "$zf" |
sort |
sed -e '/testing:/!d' -e 's/^.*testing: *//' -e 's/  *OK$//' \
-e '/\/./d' \
-e "s;.*;://$zf@:@&\">&</a>;" \
-e '/\/">/s/^/d/' \
-e 's/^/<br><a href="zipx/'
else
# path as the left side of a sed expression
path_lhs=$(echo "$path" | sed 's/[",\\.*[]/\\&/g')
unzip -t "$zf" |
sort |
sed -e '/testing:/!d' -e 's/^.*testing: *//' -e 's/  *OK$//' \
-e "s,^$path_lhs,@:@," \
-e '/^@:@/!d' -e 's/^@:@//' \
-e '/^$/d' \
-e '/\/./d' \
-e "s;.*;://$zf@:@$path&\">&</a>;" \
-e '/\/">/s/^/d/' \
-e 's/^/<br><a href="zipx/'
fi
echo "</body>"

exit 0
